<!DOCTYPE html>
<head>
  <title>t5-ruby-classes.html</title>
  <meta charset="UTF-8">
  <link rel="stylesheet" type="text/css" href="../stylesheets/blogs.css">
</head>

<main>
  <h1>One Class Example</h1>
  <h2>A simplified, broken down explanation of classes written in Ruby</h2>
  <h4>June 21, 2015</h4>

  <section>
    <p>
      One of the most important elements of modern computing is the idea of 'Object-Oriented' programming. This is the idea that most, if not all programs, are made up of with things and things those things do. Just like the real world, which is comprised of materials with characteristics, functions, and responses to stimuli, so are the objects that exist in software.
    </p>
    <p>
        Here's an example: let's say you were creating a soccer-based video game. To build a real-life soccer game you need 'things' like players, a ball, and a teams. Your video game will need all these things too! But rather than creating separate variables for every player (like wayne_rooney and hope_solo) where you'd store that player's characteristics and functions, you can create a blueprint that initializes all your players with the characteristics they'll share. This blueprint is called a class. When we ask our player class to initialize a player, it will create an 'object' with characteristics like @@species = homo sapien and @@shoes == cleats. The @@ symbol, by the way, tells Ruby that this characteristic is a class variable and is shared by all objects created by this class.
    </p>
    <p>
        But what about things like speed and strength? These are things that all soccer players have, but they have them in varying amounts. This type of data is stored in what are known as instance variables. Instance variables are preceded by the @ symbol and are intialized by the class but not actually <i>set</i> until the program specifies to do so. (Actually, instance variable are sometimes set to an initial value in the class definition, but this value can always be modified using a setter method.)
    </p>
    <p>
      Now that you have the blueprints for your objects and their characteristics and values, the class method can be rounded out with functions. Our player class, for example, will have 'run', 'shoot', and 'tackle' functions (as well as thousands more). All players will run in a similar fashion, so this method can be created using certain constants that will move the player forward on the screen, but how does that account for differing speeds? This is where instance variables come in handy. By passing in an object's data (like speed) to a method (like run), we can have one method that uses each individual object's data to produce a slightly different result! This is the beauty of classes and object-oriented programming. It allows us to make lots of things that are similar in some ways but unique in many others.
    </p>
    <p>
      Here's how you would write (in Ruby) a simple player class like the one we've been talking about. I hope you can see how the idea of object oriented programming shines through in the code!
    </p>
  </section>
  <section>
    <code>
      class Player

        #All players will be homo-sapiens wearing cleats. These are #class variables.
        #Players can have different genders, heights, speeds, and #nationalities. These are instance variables.

        def initialize(gender, height, speed, nationality)
          species = homo-sapien
          shoe_type = cleats
          @gender = gender
          @height = height
          @speed = speed
          @nationality = nationality
        end

        #These are getter and setter methods for height. Every instance #variable needs getter and setter methods. Calling the getter #method on an object outside the class will return that #object's height. The setter method can be used to set the #object's height. There is a more elegant way to do this using
        #'attr' methods, but this way is better for demonstration.

        def get_height
          @height
        end

        def set_height(player_height)
          @height = player_height
        end

        def run
          #Here we'd have code moving the player forward on the screen. The rate at which they'd move would be referred to using @speed, since that will use the specific player's unique.
        end

      end
    </code>
  </section>
</main>

